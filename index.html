<!doctype html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Поетичний складоріз</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #22d3ee;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --border: #1f2937;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: radial-gradient(120% 120% at 10% 10%, #0b162f, var(--bg));
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px;
      gap: 12px;
    }

    .app {
      width: min(1400px, 95vw);
      background: linear-gradient(145deg, #0d1727, #0b1321);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 18px 20px;
      border-bottom: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.02);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .dot { width: 10px; height: 10px; border-radius: 50%; }
    .dot.red { background: #ef4444; }
    .dot.yellow { background: #f59e0b; }
    .dot.green { background: #10b981; }

    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.02em;
      color: var(--text);
    }

    .panes {
      display: flex;
      flex-direction: column;
      gap: 1px;
      background: var(--border);
    }

    @media (min-width: 900px) {
      .panes { flex-direction: row; height: 70vh; }
      .pane { width: 50%; }
    }

    .pane {
      background: var(--panel);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #output {
      flex: 1;
      min-height: 240px;
      overflow: auto;
    }

    label {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    textarea {
      width: 100%;
      height: 100%;
      min-height: 240px;
      background: #0b1220;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      font-size: 16px;
      line-height: 1.6;
      resize: vertical;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
      overflow: auto;
      flex: 1;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      overflow: auto;
      background: #0b1220;
      border-radius: 10px;
      border: 1px solid var(--border);
      display: block;
      white-space: nowrap; /* до 20+ складів у рядку */
      font-family: "JetBrains Mono", "Fira Code", "SFMono-Regular", Consolas, "Liberation Mono", monospace;
      font-size: 13px; /* -2pt від тексту в полі */
    }

    tbody tr:nth-child(odd) { background: rgba(255, 255, 255, 0.03); }
    tbody tr:nth-child(even) { background: rgba(255, 255, 255, 0.01); }
    td {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
      font-size: 13px;
      border-right: 1px solid #1b2533;
    }

    .empty {
      color: var(--muted);
      padding: 20px;
      text-align: center;
      background: #0b1220;
      border: 1px dashed var(--border);
      border-radius: 10px;
    }

    .active-syllable {
      outline: 1px solid var(--accent);
      box-shadow: 0 0 0 2px rgba(34, 211, 238, 0.15);
    }

    .active-row {
      background: rgba(34, 211, 238, 0.08) !important;
    }

    .count-cell.active-count {
      font-weight: 700;
      color: var(--accent);
    }

    footer {
      padding: 6px 16px 4px;
      text-align: center;
      color: var(--muted);
      font-size: 13px;
      display: flex;
      justify-content: center;
      gap: 8px;
      width: min(1400px, 95vw);
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
  </style>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9FX3HCECVK"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-9FX3HCECVK');
  </script>
</head>
<body>
  <div class="app">
    <header>
      <div class="dot red"></div>
      <div class="dot yellow"></div>
      <div class="dot green"></div>
      <h1>Поетичний складоріз</h1>
    </header>
    <div class="panes">
      <div class="pane">
        <label for="input">Текст вірша</label>
        <textarea id="input" placeholder="Введіть текст, кожен рядок буде окремим рядком у таблиці"></textarea>
      </div>
      <div class="pane">
        <label>Склади</label>
        <div id="output"></div>
      </div>
    </div>
  </div>

  <script>
    const vowels = new Set(["а","е","є","и","і","ї","о","у","ю","я","А","Е","Є","И","І","Ї","О","У","Ю","Я"]);
    const wordColors = [
      "rgba(34, 211, 238, 0.12)",
      "rgba(248, 113, 113, 0.12)",
      "rgba(190, 242, 100, 0.12)",
      "rgba(129, 140, 248, 0.14)",
      "rgba(94, 234, 212, 0.12)",
      "rgba(248, 180, 127, 0.14)",
    ];

    function splitIntoSyllables(word) {
      const chars = Array.from(word);
      const syllables = [];
      let current = "";

      for (let i = 0; i < chars.length; i++) {
        current += chars[i];
        if (!vowels.has(chars[i])) continue;

        let nextVowel = -1;
        for (let j = i + 1; j < chars.length; j++) {
          if (vowels.has(chars[j])) { nextVowel = j; break; }
        }

        if (nextVowel === -1) {
          current += chars.slice(i + 1).join("");
          syllables.push(current);
          break;
        }

        const gap = nextVowel - i - 1;
        if (gap > 1) {
          // leave the last consonant for the next syllable
          const keep = chars.slice(i + 1, nextVowel - 1).join("");
          current += keep;
          syllables.push(current);
          current = chars[nextVowel - 1];
          i = nextVowel - 1; // skip ahead to the held consonant; next loop hits the vowel
        } else {
          syllables.push(current);
          current = "";
        }
      }

      if (current && !syllables.length) syllables.push(current);
      else if (current && syllables[syllables.length - 1] !== current) syllables.push(current);
      return syllables.filter(Boolean);
    }

    function buildLineStarts(text) {
      const starts = [0];
      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        if (ch === "\r") {
          if (text[i + 1] === "\n") {
            starts.push(i + 2);
            i++;
          } else {
            starts.push(i + 1);
          }
        } else if (ch === "\n") {
          starts.push(i + 1);
        }
      }
      return starts;
    }

    function nonHyphenPositions(rawWord, startIndex) {
      const positions = [];
      for (let i = 0; i < rawWord.length; i++) {
        if (/[-–—]/.test(rawWord[i])) continue;
        positions.push(startIndex + i);
      }
      return positions;
    }

    function processText(text) {
      const lines = text.split(/\r?\n/);
      const lineStarts = buildLineStarts(text);
      const table = document.createElement("table");

      const tbody = document.createElement("tbody");
      const mapping = [];

      lines.forEach((line, lineIndex) => {
        const row = document.createElement("tr");
        const wordMatches = [...line.matchAll(/[А-Яа-яЇїІіЄєҐґ'’\-]+/g)];
        const words = [];
        wordMatches.forEach(match => {
          const raw = match[0];
          const cleaned = raw.replace(/[-–—]/g, "");
          if (!cleaned) return;
          words.push({
            cleaned,
            positions: nonHyphenPositions(raw, match.index)
          });
        });
        const cells = [];

        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          const isSingleConsonant = word.cleaned.length === 1 && !vowels.has(word.cleaned);

          if (isSingleConsonant && i < words.length - 1) {
            const nextWord = words[i + 1];
            const nextSyllables = splitIntoSyllables(nextWord.cleaned);
            if (nextSyllables.length) {
              const combinedFirst = nextSyllables.shift();
              cells.push({
                color: wordColors[(i + 1) % wordColors.length],
                segments: [
                  { text: word.cleaned, italic: true },
                  { text: " " + combinedFirst }
                ],
                start: word.positions[0],
                end: nextWord.positions[combinedFirst.length - 1]
              });
              let offset = combinedFirst.length;
              nextSyllables.forEach(syl => {
                cells.push({
                  color: wordColors[(i + 1) % wordColors.length],
                  segments: [{ text: syl }],
                  start: nextWord.positions[offset],
                  end: nextWord.positions[offset + syl.length - 1]
                });
                offset += syl.length;
              });
              i++; // skip the next word, already consumed
              continue;
            }
            // if next word has no syllables, fall through to normal handling
          }

          const wordSyllables = splitIntoSyllables(word.cleaned);
          const color = wordColors[i % wordColors.length];
          if (!wordSyllables.length) {
            cells.push({ color, segments: [{ text: word.cleaned }], start: word.positions[0], end: word.positions[word.positions.length - 1] });
          } else {
            let pos = 0;
            wordSyllables.forEach(syl => {
              const startIdx = word.positions[pos];
              const endIdx = word.positions[pos + syl.length - 1];
              cells.push({ color, segments: [{ text: syl }], start: startIdx, end: endIdx });
              pos += syl.length;
            });
          }
        }

        const countCell = document.createElement("td");
        countCell.className = "count-cell";
        countCell.textContent = cells.length || 0;
        row.appendChild(countCell);

        if (!cells.length) {
          const emptyCell = document.createElement("td");
          emptyCell.textContent = "—";
          row.appendChild(emptyCell);
        } else {
          cells.forEach((cellData, idx) => {
            const cell = document.createElement("td");
            cell.style.backgroundColor = cellData.color;
            cell.title = `Рядок ${lineIndex + 1}, склад ${idx + 1}`;
            cellData.segments.forEach(seg => {
              const span = document.createElement("span");
              if (seg.italic) span.style.fontStyle = "italic";
              span.textContent = seg.text;
              cell.appendChild(span);
            });
            row.appendChild(cell);
            mapping.push({
              start: lineStarts[lineIndex] + cellData.start,
              end: lineStarts[lineIndex] + cellData.end,
              cell,
              row,
              countCell,
              lineIndex
            });
          });
        }

        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      return { table, mapping };
    }

    const input = document.getElementById("input");
    const output = document.getElementById("output");
    let currentMapping = [];
    let activeCell = null;
    let activeRow = null;
    let activeCount = null;

    function clearRowHighlight() {
      if (activeRow) {
        activeRow.classList.remove("active-row");
        activeRow = null;
      }
      if (activeCount) {
        activeCount.classList.remove("active-count");
        activeCount = null;
      }
    }

    function clearActive() {
      if (activeCell) {
        activeCell.classList.remove("active-syllable");
        activeCell = null;
      }
      clearRowHighlight();
    }

    function getLineIndex(pos, lineStarts) {
      let idx = 0;
      for (let i = 0; i < lineStarts.length; i++) {
        if (pos >= lineStarts[i]) idx = i;
        else break;
      }
      return idx;
    }

    function highlightCursor(lineStarts) {
      if (!currentMapping.length) { clearActive(); return; }
      const pos = input.selectionStart ?? 0;
      const lineIdx = getLineIndex(pos, lineStarts);
      const lineMappings = currentMapping.filter(m => m.lineIndex === lineIdx);
      if (!lineMappings.length) { clearActive(); return; }

      let target = lineMappings.find(m => pos >= m.start && pos <= m.end);
      if (!target) {
        target = lineMappings.find(m => m.start >= pos) || lineMappings[lineMappings.length - 1];
      }

      if (activeCell && activeCell !== target.cell) {
        activeCell.classList.remove("active-syllable");
        activeCell = null;
      }
      clearRowHighlight();

      if (target) {
        target.cell.classList.add("active-syllable");
        target.row.classList.add("active-row");
        target.countCell.classList.add("active-count");
        activeCell = target.cell;
        activeRow = target.row;
        activeCount = target.countCell;
        target.cell.scrollIntoView({ block: "nearest", inline: "nearest" });
      }
    }

    function render() {
      output.innerHTML = "";
      const text = input.value;
      if (!text.trim()) {
        clearActive();
        currentMapping = [];
        const empty = document.createElement("div");
        empty.className = "empty";
        empty.textContent = "Склади з'являться тут";
        output.appendChild(empty);
        return;
      }
      const { table, mapping } = processText(text);
      output.appendChild(table);
      currentMapping = mapping;
      highlightCursor(buildLineStarts(text));
    }

    input.addEventListener("input", () => { render(); });
    ["click", "keyup", "mouseup", "select", "focus"].forEach(evt => {
      input.addEventListener(evt, () => highlightCursor(buildLineStarts(input.value)));
    });
    render();

    // sync scrolling between input and output for long texts
    (function syncScroll() {
      let syncing = false;
      const update = (source, target) => {
        if (syncing) return;
        syncing = true;
        const maxSource = Math.max(1, source.scrollHeight - source.clientHeight);
        const maxTarget = Math.max(1, target.scrollHeight - target.clientHeight);
        const ratio = source.scrollTop / maxSource;
        target.scrollTop = ratio * maxTarget;
        syncing = false;
      };
      input.addEventListener("scroll", () => update(input, output));
      output.addEventListener("scroll", () => update(output, input));
    })();
  </script>
  <footer>
    <span>Поетичний складоріз (c) 2025 - Victor Haydin</span>
    <span>·</span>
    <a href="https://linktr.ee/victorhaydin" target="_blank" rel="noreferrer noopener">Контакти</a>
  </footer>
</body>
</html>
